<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">

  <title>Java Interview Q&A</title>
  <meta content="" name="description">
  <meta content="" name="keywords">

  <!-- Favicons -->
  <link href="assets/img/favicon.png" rel="icon">
  <link href="assets/img/apple-touch-icon.png" rel="apple-touch-icon">

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i|Raleway:300,300i,400,400i,500,500i,600,600i,700,700i|Poppins:300,300i,400,400i,500,500i,600,600i,700,700i" rel="stylesheet">

  <!-- Vendor CSS Files -->
  <link href="assets/vendor/animate.css/animate.min.css" rel="stylesheet">
  <link href="assets/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="assets/vendor/bootstrap-icons/bootstrap-icons.css" rel="stylesheet">
  <link href="assets/vendor/boxicons/css/boxicons.min.css" rel="stylesheet">
  <link href="assets/vendor/glightbox/css/glightbox.min.css" rel="stylesheet">
  <link href="assets/vendor/remixicon/remixicon.css" rel="stylesheet">
  <link href="assets/vendor/swiper/swiper-bundle.min.css" rel="stylesheet">

  <!-- Template Main CSS File -->
  <link href="assets/css/style.css" rel="stylesheet">

  <script src="https://code.jquery.com/jquery-3.3.1.js" integrity="sha256-2Kok7MbOyxpgUVvAk/HJ2jigOSYS2auK4Pfzbm7uH60=" crossorigin="anonymous"></script>
  <script> $(function(){$("#header").load("header.html"); $("#footer").load("footer.html");  }); </script>


  <!-- =======================================================
  * Template Name: Sailor - v4.9.1
  * Template URL: https://bootstrapmade.com/sailor-free-bootstrap-theme/
  * Author: BootstrapMade.com
  * License: https://bootstrapmade.com/license/
  ======================================================== -->
</head>

<body>

  <div id="header"></div>

<main id="main">

    <section id="about" class="about">
      <div class="container">
        <div class="row-content"> 
          
            
            <ui><li><label><strong> What is Testing?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Testing is the process of checking the functionality of the application whether it is working as per requirements.</p>
            </div>
            
            
            <ui><li><label><strong> What is Unit Testing?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Unit testing is the testing of single entity (class or method). Unit testing is very essential to every software company to give a quality product to their customers.</p>
            </div>
            
            
            <ui><li><label><strong> What is Manual testing?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Executing the test cases manually without any tool support is known as manual testing.</p>
            </div>
            
            
            <ui><li><label><strong> What is Automated testing?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Taking tool support and executing the test cases by using automation tool is known as automation testing.</p>
            </div>
            
            
            <ui><li><label><strong> What are the disadvantages of manual testing?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Following are the disadvantages of manual testing −</p>
            <ol class="list">
            <li><p>Time consuming and tedious − Since test cases are executed by human resources so it is very slow and tedious.</p></li>
            <li><p>Huge investment in human resources − As test cases need to be executed manually so more testers are required in manual testing.</p></li>
            <li><p>Less reliable − Manual testing is less reliable as tests may not be performed with precision each time because of human errors.</p></li>
            <li><p>Non-programmable − No programming can be done to write sophisticated tests which fetch hidden information.</p></li>
            </ol>
            </div>
            
            
            <ui><li><label><strong> What are the advantages of automated testing?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Following are the advantages of automated testing −</p>
            <ol class="list">
            <li><p><b>Fast</b> − Automation runs test cases significantly faster than human resources.</p></li>
            <li><p><b>Less investment in human resources</b> − Test cases are executed by using automation tool so less tester are required in automation testing.</p></li>
            <li><p><b>More reliable</b> − Automation tests perform precisely same operation each time they are run.</p></li>
            <li><p><b>Programmable</b> − Testers can program sophisticated tests to bring out hidden information.</p></li>
            </ol>
            </div>
            
            
            <ui><li><label><strong> What is JUnit?</strong></label></li></ui>
            <div class="toggle-content">
            <p>JUnit is a Regression Testing Framework used by developers to implement unit testing in Java and accelerate programming speed and increase the quality of code.</p>
            </div>
            
            
            <ui><li><label><strong> What are important features of JUnit?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Following are the important features of JUnit −</p>
            <ol class="list">
            <li><p>It is an open source framework.</p></li>
            <li><p>Provides Annotation to identify the test methods.</p></li>
            <li><p>Provides Assertions for testing expected results.</p></li>
            <li><p>Provides Test runners for running tests.</p></li>
            <li><p>JUnit tests can be run automatically and they check their own results and provide immediate feedback.</p></li>
            <li><p>JUnit tests can be organized into test suites containing test cases and even other test suites.</p></li>
            <li><p>JUnit shows test progress in a bar that is green if test is going fine and it turns red when a test fails.</p></li>
            </ol>
            </div>
            
            
            <ui><li><label><strong> What is a Unit Test Case?</strong></label></li></ui>
            <div class="toggle-content">
            <p>A Unit Test Case is a part of code which ensures that the another part of code (method) works as expected. To achieve those desired results quickly, test framework is required .JUnit is perfect unit test framework for java programming language.</p>
            </div>
            
            
            <ui><li><label><strong> What are the best practices to write a Unit Test Case?</strong></label></li></ui>
            <div class="toggle-content">
            <p>A formal written unit test case is characterized by a known input and by an expected output, which is worked out before the test is executed. The known input should test a precondition and the expected output should test a postcondition.</p>
            <p>There must be at least two unit test cases for each requirement: one positive test and one negative test. If a requirement has sub-requirements, each sub-requirement must have at least two test cases as positive and negative.</p>
            </div>
            
            
            <ui><li><label><strong> When are Unit Tests written in Development Cycle?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Tests are written before the code during development in order to help coders write the best code.</p>
            </div>
            
            
            <ui><li><label><strong> Why not just use System.out.println() for testing?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Debugging the code using system.out.println() will lead to manual scanning of the whole output every time the program is run to ensure the code is doing the expected operations. Moreover, in the long run, it takes lesser time to code JUnit methods and test them on class files.</p>
            </div>
            
            
            <ui><li><label><strong> How to install JUnit?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Follow the steps below −</p>
            <ol class="list">
            <li><p>Download the latest version of JUnit, referred to below as junit.zip.</p></li>
            <li><p>Unzip the junit.zip distribution file to a directory referred to as %JUNIT_HOME%.</p></li>
            <li><p>Add JUnit to the classpath −</p></li>
            </ol>
            <pre class="result notranslate">set CLASSPATH=%CLASSPATH%;%JUNIT_HOME%\junit.jar
            </pre>
            <ul class="list">
            <li><p>Test the installation by running the sample tests distributed with JUnit (sample tests are located in the installation directory directly, not the junit.jar file). Then simply type −</p></li>
            </ul>
            <pre class="result notranslate">java org.junit.runner.JUnitCore org.junit.tests.AllTests
            </pre>
            <ul class="list">
            <li><p>All the tests should pass with an "OK" message. If the tests don't pass, verify that junit.jar is in the CLASSPATH.</p></li>
            </ul>
            </div>
            
            
            <ui><li><label><strong> Why does JUnit only report the first failure in a single test?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Reporting multiple failures in a single test is generally a sign that the test does too much and it is too big a unit test. JUnit is designed to work best with a number of small tests. It executes each test within a separate instance of the test class. It reports failure on each test.</p>
            </div>
            
            
            <ui><li><label><strong> In Java, assert is a keyword. Won't this conflict with JUnit's assert() method?</strong></label></li></ui>
            <div class="toggle-content">
            <p>JUnit 3.7 deprecated assert() and replaced it with assertTrue(), which works exactly the same way. JUnit 4 is compatible with the assert keyword. If you run with the -ea JVM switch, assertions that fail will be reported by JUnit.</p>
            </div>
            
            
            <ui><li><label><strong> How do I test things that must be run in a J2EE container (e.g. servlets, EJBs)?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Refactoring J2EE components to delegate functionality to other objects that don't have to be run in a J2EE container will improve the design and testability of the software. Cactus is an open source JUnit extension that can be used for unit testing server-side java code.</p>
            </div>
            
            
            <ui><li><label><strong> Name the tools with which JUnit can be easily integrated.</strong></label></li></ui>
            <div class="toggle-content">
            <p>JUnit Framework can be easily integrated with either of the followings −</p>
            <ol class="list">
            <li>Eclipse</li>
            <li>Ant</li>
            <li>Maven</li>
            </ol>
            </div>
            
            
            <ui><li><label><strong> What are the core features of JUnit?</strong></label></li></ui>
            <div class="toggle-content">
            <p>JUnit test framework provides following important features −</p>
            <ol class="list">
            <li>Fixtures</li>
            <li>Test suites</li>
            <li>Test runners</li>
            <li>JUnit classes</li>
            </ol>
            </div>
            
            
            <ui><li><label><strong> What is a fixture?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Fixture is a fixed state of a set of objects used as a baseline for running tests. The purpose of a test fixture is to ensure that there is a well known and fixed environment in which tests are run so that results are repeatable. It includes following methods −</p>
            <ol class="list">
            <li><p>setUp() method which runs before every test invocation.</p></li>
            <li><p>tearDown() method which runs after every test method.</p></li>
            </ol>
            </div>
            
            
            <ui><li><label><strong> What is a test suite?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Test suite means bundle a few unit test cases and run it together. In JUnit, both @RunWith and @Suite annotation are used to run the suite test.</p>
            </div>
            
            
            <ui><li><label><strong> What is a test runner?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Test runner is used for executing the test cases.</p>
            </div>
            
            
            <ui><li><label><strong> What are JUnit classes? List some of them.</strong></label></li></ui>
            <div class="toggle-content">
            <p>JUnit classes are important classes which are used in writing and testing JUnits. Some of the important classes are −</p>
            <ul class="list">
            <li><p><b>Assert</b> − It contains a set of assert methods.</p></li>
            <li><p><b>TestCase</b> − It contains a test case defines the fixture to run multiple tests.</p></li>
            <li><p><b>TestResult</b> − It contains methods to collect the results of executing a test case.</p></li>
            <li><p><b>TestSuite</b> − It is a Composite of Tests.</p></li>
            </ul>
            </div>
            
            
            <ui><li><label><strong> What are annotations and how are they useful in JUnit?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Annotations are like meta-tags that you can add to you code and apply them to methods or in class. The annotation in JUnit gives us information about test methods, which methods are going to run before &amp; after test methods, which methods run before &amp; after all the methods, which methods or class will be ignore during execution.</p>
            </div>
            
            
            <ui><li><label><strong> How will you run JUnit from command window?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Follow the steps below −</p>
            <ul class="list">
            <li><p>Set the CLASSPATH</p></li>
            <li><p>Invoke the runner −</p></li>
            </ul>
            <pre class="result notranslate">java org.junit.runner.JUnitCore 
            </pre>
            </div>
            
            
            <ui><li><label><strong> What is the purpose of org.junit.Assert class?</strong></label></li></ui>
            <div class="toggle-content">
            <p>This class provides a set of assertion methods useful for writing tests. Only failed assertions are recorded.</p>
            </div>
            
            
            <ui><li><label><strong> What is the purpose of org.junit.TestResult class?</strong></label></li></ui>
            <div class="toggle-content">
            <p>A TestResult collects the results of executing a test case. It is an instance of the Collecting Parameter pattern. The test framework distinguishes between failures and errors. A failure is anticipated and checked for with assertions. Errors are unanticipated problems like an ArrayIndexOutOfBoundsException.</p>
            </div>
            
            
            <ui><li><label><strong> What is the purpose of org.junit.TestSuite class?</strong></label></li></ui>
            <div class="toggle-content">
            <p>A TestSuite is a Composite of Tests. It runs a collection of test cases.</p>
            </div>
            
            
            <ui><li><label><strong> What is the purpose of @Test annotation in JUnit?</strong></label></li></ui>
            <div class="toggle-content">
            <p>The Test annotation tells JUnit that the public void method to which it is attached can be run as a test case.</p>
            </div>
            
            
            <ui><li><label><strong> What is the purpose of @Before annotation in JUnit?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Several tests need similar objects created before they can run. Annotating a public void method with @Before causes that method to be run before each Test method.</p>
            </div>
            
            
            <ui><li><label><strong> What is the purpose of @After annotation in JUnit?</strong></label></li></ui>
            <div class="toggle-content">
            <p>If you allocate external resources in a Before method you need to release them after the test runs. Annotating a public void method with @After causes that method to be run after the Test method.</p>
            </div>
            
            
            <ui><li><label><strong> What is the purpose of @BeforeClass annotation in JUnit?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Annotating a public static void method with @BeforeClass causes it to be run once before any of the test methods in the class.</p>
            </div>
            
            
            <ui><li><label><strong> What is the purpose of @AfterClass annotation in JUnit?</strong></label></li></ui>
            <div class="toggle-content">
            <p>This will perform the method after all tests have finished. This can be used to perform clean-up activities.</p>
            </div>
            
            
            <ui><li><label><strong> What is @Ignore annotation and how is this useful?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Following are some of the usefulness of @Ignore annotation −</p>
            <p>You can easily identify all @Ignore annotations in the source code, while unannotated or commented out tests are not so simple to find.</p>
            <p>There are cases when you can't fix a code that is failing, but you still want to method to be around, precisely so that it does not get forgotten. In such cases @Ignore makes sense.</p>
            </div>
            
            
            <ui><li><label><strong> Explain the execution procedure of the JUnit test API methods?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Following is how the JUnit execution procedure works −</p>
            <ol class="list">
            <li><p>First of all method annotated as @BeforeClass execute only once.</p></li>
            <li><p>Lastly, the method annotated as @AfterClass executes only once.</p></li>
            <li><p>Method annotated as @Before executes for each test case but before executing the test case.</p></li>
            <li><p>Method annotated as @After executes for each test case but after the execution of test case.</p></li>
            <li><p>In between method annotated as @Before and method annotated as @After each test case executes.</p></li>
            </ol>
            </div>
            
            
            <ui><li><label><strong> What is the purpose of org.junit.JUnitCore class?</strong></label></li></ui>
            <div class="toggle-content">
            <p>The test cases are executed using JUnitCore class. JUnitCore is a facade for running tests. It supports running JUnit 4 tests, JUnit 3.8.x tests, and mixtures.</p>
            </div>
            
            
            <ui><li><label><strong> How to simulate timeout situation in JUnit?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Junit provides a handy option of Timeout. If a test case takes more time than specified number of milliseconds then Junit will automatically mark it as failed. The timeout parameter is used along with @Test annotation.</p>
            </div>
            
            
            <ui><li><label><strong> How can you use JUnit to test that the code throws desired exception?</strong></label></li></ui>
            <div class="toggle-content">
            <p>JUnit provides a option of tracing the Exception handling of code. You can test if a code throws desired exception or not. The expected parameter is used along with @Test annotation as follows − @Test(expected)</p>
            </div>
            
            
            <ui><li><label><strong> What are Parameterized tests?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Junit 4 has introduced a new feature Parameterized tests. Parameterized tests allow developer to run the same test over and over again using different values. </p>
            </div>
            
            
            <ui><li><label><strong> How to create Parameterized tests?</strong></label></li></ui>
            <div class="toggle-content">
            <p>There are five steps, that you need to follow to create Parameterized tests−</p>
            <ol class="list">
            <li><p>Annotate test class with @RunWith(Parameterized.class).</p></li>
            <li><p>Create a public static method annotated with @Parameters that returns a Collection of Objects (as Array) as test data set.</p></li>
            <li><p>Create a public constructor that takes in what is equivalent to one "row" of test data.</p></li>
            <li><p>Create an instance variable for each "column" of test data.</p></li>
            <li><p>Create your tests case(s) using the instance variables as the source of the test data.</p></li>
            <li><p>The test case will be invoked once per each row of data. Let's see Parameterized tests in action.</p></li>
            </ol>
            </div>
            
            
            <ui><li><label><strong> How do you use test fixtures?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Fixtures is a fixed state of a set of objects used as a baseline for running tests. The purpose of a test fixture is to ensure that there is a well known and fixed environment in which tests are run so that results are repeatable. It includes −</p>
            <ul class="list">
            <li><p>setUp() method which runs before every test invocation.</p></li>
            <li><p>tearDown() method which runs after every test method.</p></li>
            </ul>
            </div>
            
            
            <ui><li><label><strong> How to compile a JUnit Test Class?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Compiling a JUnit test class is like compiling any other Java classes. The only thing you need watch out is that the JUnit JAR file must be included in the classpath.</p>
            </div>
            
            
            <ui><li><label><strong> What happens if a JUnit Test Method is Declared as "private"?</strong></label></li></ui>
            <div class="toggle-content">
            <p>If a JUnit test method is declared as "private", it compiles successfully. But the execution will fail. This is because JUnit requires that all test methods must be declared as "public".</p>
            </div>
            
            
            <ui><li><label><strong> How do you test a "protected" method?</strong></label></li></ui>
            <div class="toggle-content">
            <p>When a method is declared as "protected", it can only be accessed within the same package where the class is defined. Hence to test a "protected" method of a target class, define your test class in the same package as the target class.</p>
            </div>
            
            
            <ui><li><label><strong> How do you test a "private" method?</strong></label></li></ui>
            <div class="toggle-content">
            <p>When a method is declared as "private", it can only be accessed within the same class. So there is no way to test a "private" method of a target class from any test class. Hence you need to perform unit testing manually. Or you have to change your method from "private" to "protected".</p>
            </div>
            
            
            <ui><li><label><strong> What happens if a JUnit test method is declared to return "String"?</strong></label></li></ui>
            <div class="toggle-content">
            <p>If a JUnit test method is declared to return "String", the compilation will pass ok. But the execution will fail. This is because JUnit requires that all test methods must be declared to return "void".</p>
            </div>
            
            
            <ui><li><label><strong> Can you use a main() Method for Unit Testing?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Yes you can test using main() method. One obvious advantage seems to be that you can whitebox test the class. That is, you can test the internals of it (private methods for example). You can't do that with unit-tests. But primarily the test framework tests the interface and the behavior from the user's perspective.</p>
            </div>
            
            
            <ui><li><label><strong> Do you need to write a test class for every class that needs to be tested?</strong></label></li></ui>
            <div class="toggle-content">
            <p>No. We need not write an independent test class for every class that needs to be tested. If there is a small group of tests sharing a common test fixture, you may move those tests to a new test class.</p>
            </div>
            
            
            <ui><li><label><strong> When are tests garbage collected?</strong></label></li></ui>
            <div class="toggle-content">
            <p>The test runner holds strong references to all Test instances for the duration of the test execution. This means that for a very long test run with many Test instances, none of the tests may be garbage collected until the end of the entire test run. Explicitly setting an object to null in the tearDown() method, for example, allows it to be garbage collected before the end of the entire test run.</p>
            </div>
            
            
            <ui><li><label><strong> What is a Mock Object?</strong></label></li></ui>
            <div class="toggle-content">
            <p>In a unit test, mock objects can simulate the behavior of complex, real (non-mock) objects and are therefore useful when a real object is impractical or impossible to incorporate into a unit test.</p>
            </div>
            
            
            <ui><li><label><strong> Explain unit testing using Mock Objects.</strong></label></li></ui>
            <div class="toggle-content">
            <p>The common coding style for testing with mock objects is to −</p>
            <ol class="list">
            <li>Create instances of mock objects.</li>
            <li>Set state and expectations in the mock objects.</li>
            <li>Invoke domain code with mock objects as parameters.</li>
            <li>Verify consistency in the mock objects.</li>
            </ol>
            </div>
            
            
            <ui><li><label><strong> Name some of the JUnit Extensions.</strong></label></li></ui>
            <div class="toggle-content">
            <p>Following are the JUnit extensions −</p>
            <ol class="list">
            <li><p>Cactus</p></li>
            <li><p>JWebUnit</p></li>
            <li><p>XMLUnit</p></li>
            <li><p>MockObject</p></li>
            </ol>
            </div>
            
            
            <ui><li><label><strong> What is Cactus?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Cactus is a simple test framework for unit testing server-side java code (Servlets, EJBs, Tag Libs, Filters). The intent of Cactus is to lower the cost of writing tests for server-side code. It uses JUnit and extends it. Cactus implements an in-container strategy, meaning that tests are executed inside the container.</p>
            </div>
            
            
            <ui><li><label><strong> What are the core components of Cactus?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Cactus Ecosystem is made of several components −</p>
            <ol class="list">
            <li><p>Cactus Framework is the heart of Cactus. It is the engine that provides the API to write Cactus tests.</p></li>
            <li><p>Cactus Integration Modules are front ends and frameworks that provide easy ways of using the Cactus Framework (Ant scripts, Eclipse plugin, Maven plugin).</p></li>
            </ol>
            </div>
            
            
            <ui><li><label><strong> What is JWebUnit?</strong></label></li></ui>
            <div class="toggle-content">
            <p>WebUnit is a Java-based testing framework for web applications. It wraps existing testing frameworks such as HtmlUnit and Selenium with a unified, simple testing interface to allow you to quickly test the correctness of your web applications.</p>
            </div>
            
            
            <ui><li><label><strong> What are the advantages of using JWebUnit?</strong></label></li></ui>
            <div class="toggle-content">
            <p>JWebUnit provides a high-level Java API for navigating a web application combined with a set of assertions to verify the application's correctness. This includes navigation via links, form entry and submission, validation of table contents, and other typical business web application features.</p>
            <p>The simple navigation methods and ready-to-use assertions allow for more rapid test creation than using only JUnit or HtmlUnit. And if you want to switch from HtmlUnit to other plugins such as Selenium (available soon), there is no need to rewrite your tests.</p>
            </div>
            
            
            <ui><li><label><strong> What is XMLUnit?</strong></label></li></ui>
            <div class="toggle-content">
            <p>XMLUnit provides a single JUnit extension class, XMLTestCase, and a set of supporting classes.</p>
            </div>
            
            
            <ui><li><label><strong> What is the use of supporting classes in XMLUnit?</strong></label></li></ui>
            <div class="toggle-content">
            <p>Supporting classes allow assertions to be made about−</p>
            <ol class="list">
            <li><p>The differences between two pieces of XML (via Diff and DetailedDiff classes).</p></li>
            <li><p>The validity of a piece of XML (via Validator class).</p></li>
            <li><p>The outcome of transforming a piece of XML using XSLT (via Transform class).</p></li>
            <li><p>The evaluation of an XPath expression on a piece of XML (via classes implementing the XpathEngine interface).</p></li>
            <li><p>Individual nodes in a piece of XML that are exposed by DOM Traversal (via NodeTest class).</p></li>
            </ol>
            </div>
            
            


        </div>	
      </div>
    

  </main><!-- End #main -->


  <div id="footer"></div>


</body>

</html>